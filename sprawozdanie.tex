\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{pgfplots}
\usepackage{tikz}
\pgfplotsset{compat=1.18}
\usetikzlibrary{shapes,arrows,positioning}

\geometry{margin=2.5cm}

\title{\textbf{Sprawozdanie z Projektu CSP} \\
\large System Producent-Konsument z Tablicami Wag i Dispatcherami}
\author{Marcel}
\date{\today}

\lstset{
    language=Java,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    frame=single
}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Wprowadzenie}

Niniejsze sprawozdanie przedstawia implementację i analizę wydajności systemu producent-konsument wykorzystującego paradygmat CSP (Communicating Sequential Processes) oraz bibliotekę JCSP. System charakteryzuje się dynamicznym równoważeniem obciążenia przy użyciu tablic wag oraz procesów dispatcher.

\subsection{Cel projektu}

Głównym celem projektu było:
\begin{itemize}
    \item Implementacja systemu producent-konsument z wieloma buforami
    \item Zastosowanie dynamicznego równoważenia obciążenia
    \item Analiza wydajności w różnych konfiguracjach
    \item Ocena równomierności rozkładu danych między bufory
\end{itemize}

\section{Architektura Systemu}

\subsection{Schemat działania}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.5cm and 1.2cm,
    process/.style={rectangle, draw, fill=blue!20, text width=2cm, text centered, minimum height=0.8cm, font=\small},
    buffer/.style={rectangle, draw, fill=green!20, text width=1.5cm, text centered, minimum height=0.8cm, font=\small},
    dispatcher/.style={ellipse, draw, fill=orange!20, text width=1.8cm, text centered, minimum height=0.8cm, font=\small},
    arrow/.style={->,>=stealth,thick}
]

% Producenci (lewa strona)
\node[process] (p1) at (0,2) {Producent 1};
\node[process] (p2) at (0,0.5) {Producent 2};
\node[process] (p3) at (0,-1) {Producent P};

% Dispatcher producentów
\node[dispatcher] (pd) at (3,0.5) {Producer\\Dispatcher};

% Bufory (środek)
\node[buffer] (b1) at (6,2) {Bufor 0};
\node[buffer] (b2) at (6,0.5) {Bufor 1};
\node[buffer] (b3) at (6,-1) {Bufor B};

% Dispatcher konsumentów
\node[dispatcher] (cd) at (9,0.5) {Consumer\\Dispatcher};

% Konsumenci (prawa strona)
\node[process] (c1) at (12,2) {Konsument 1};
\node[process] (c2) at (12,0.5) {Konsument 2};
\node[process] (c3) at (12,-1) {Konsument K};

% Połączenia producentów
\draw[arrow] (p1) -- node[above,font=\tiny] {dane} (b1);
\draw[arrow] (p1) -- (b2);
\draw[arrow] (p2) -- (b1);
\draw[arrow] (p2) -- (b2);
\draw[arrow] (p2) -- (b3);
\draw[arrow] (p3) -- (b2);
\draw[arrow] (p3) -- (b3);

% Synchronizacja producentów z dispatcherem
\draw[arrow,dashed,red] (p1) to[bend left=15] node[above,font=\tiny] {sync} (pd);
\draw[arrow,dashed,red] (pd) to[bend left=15] (p1);
\draw[arrow,dashed,red] (p2) -- (pd);
\draw[arrow,dashed,red] (pd) -- (p2);
\draw[arrow,dashed,red] (p3) to[bend right=15] (pd);
\draw[arrow,dashed,red] (pd) to[bend right=15] (p3);

% Połączenia konsumentów
\draw[arrow] (b1) -- (c1);
\draw[arrow] (b2) -- (c1);
\draw[arrow] (b1) -- (c2);
\draw[arrow] (b2) -- (c2);
\draw[arrow] (b3) -- (c2);
\draw[arrow] (b2) -- (c3);
\draw[arrow] (b3) -- (c3);

% Synchronizacja konsumentów z dispatcherem
\draw[arrow,dashed,blue] (c1) to[bend right=15] node[above,font=\tiny] {sync} (cd);
\draw[arrow,dashed,blue] (cd) to[bend right=15] (c1);
\draw[arrow,dashed,blue] (c2) -- (cd);
\draw[arrow,dashed,blue] (cd) -- (c2);
\draw[arrow,dashed,blue] (c3) to[bend left=15] (cd);
\draw[arrow,dashed,blue] (cd) to[bend left=15] (c3);

% Legenda
\node[font=\tiny,align=left] at (6,-2.5) {
    \textbf{Legenda:} \\
    \tikz\draw[arrow] (0,0) -- (0.3,0); dane (wybór losowy z wagami) \\
    \tikz\draw[arrow,dashed,red] (0,0) -- (0.3,0); synchronizacja (agregacja czasów)
};

\end{tikzpicture}
\caption{Architektura systemu: producenci wybierają bufory probabilistycznie na podstawie wag, następnie synchronizują się z dispatcherem aby zaktualizować wagi globalnie. Konsumenci działają analogicznie.}
\label{fig:architecture}
\end{figure}

\subsection{Komponenty systemu}

\subsubsection{Producenci}

Każdy producent:
\begin{itemize}
    \item Generuje elementy danych
    \item Utrzymuje tablicę wag dla każdego bufora i dispatchera
    \item Wybiera cel na podstawie rozkładu prawdopodobieństwa
    \item Aktualizuje wagi na podstawie czasów oczekiwania
\end{itemize}

\subsubsection{Bufory}

Bufory zaimplementowane jako \texttt{ArrayBlockingQueue}:
\begin{itemize}
    \item Obsługują wielowątkowy dostęp
    \item Implementują mechanizm timeout
    \item Przechowują dane tymczasowo między producentami a konsumentami
\end{itemize}

\subsubsection{Dispatcher}

Procesy dispatcher agregują informacje o czasach oczekiwania i rozgłaszają je wszystkim procesom, umożliwiając globalne równoważenie obciążenia.

\subsubsection{Konsumenci}

Każdy konsument:
\begin{itemize}
    \item Pobiera elementy z buforów
    \item Śledzi żywe i martwe bufory
    \item Aktualizuje wagi na podstawie dostępności danych
    \item Synchronizuje się z dispatcherem
\end{itemize}

\subsection{Algorytm równoważenia obciążenia}

Wagi są aktualizowane według wzoru:
\begin{equation}
w_i^{new} = \alpha \cdot w_i^{old} + (1-\alpha) \cdot \frac{1}{1 + \frac{t_i}{1000000}}
\end{equation}

gdzie:
\begin{itemize}
    \item $w_i$ -- waga bufora $i$
    \item $t_i$ -- czas oczekiwania w nanosekundach
    \item $\alpha = 0.7$ -- współczynnik wygładzania (lokalnie), $0.5$ (globalnie)
\end{itemize}

\section{Konfiguracja Testów}

Przeprowadzono 75 testów w różnych konfiguracjach, zgrupowanych w serie:

\begin{table}[H]
\centering
\caption{Serie testów}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Seria} & \textbf{Cel} & \textbf{Parametry} \\ \midrule
1 & Skalowalność P, K & P=K $\in$ \{5,10,20,50,100\}, B=3 \\
2 & Skalowalność B & B $\in$ \{1,3,5,10,20\}, P=K=20 \\
3 & Asymetria P/K & P$\neq$K, B=5 \\
4 & Proporcjonalne & P:B:K = 10:1:10 \\
5 & Duże liczby & P=K=100, B $\in$ \{1,5,10,20,50\} \\
\bottomrule
\end{tabular}
\end{table}

\section{Wyniki Eksperymentów}

\subsection{Seria 1: Skalowalność liczby procesów}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    xlabel={Liczba producentów/konsumentów},
    ylabel={Przepustowość [elem/s]},
    legend pos=north west,
    grid=major,
    width=0.8\textwidth,
    height=6cm
]
\addplot[color=blue,mark=*,thick] coordinates {
    (5,126641)
    (10,198305)
    (20,237645)
    (50,322498)
    (100,436761)
};
\legend{Przepustowość}
\end{axis}
\end{tikzpicture}
\caption{Przepustowość w funkcji liczby procesów (B=3)}
\label{fig:throughput_scale}
\end{figure}

\textbf{Obserwacje:}
\begin{itemize}
    \item Przepustowość rośnie wraz z liczbą procesów
    \item Przy 100 procesach: 436 761 elem/s
    \item Współczynnik zmienności $< 0.1\%$ -- doskonałe równoważenie
\end{itemize}

\subsection{Seria 2: Wpływ liczby buforów}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    xlabel={Liczba buforów},
    ylabel={Przepustowość [elem/s]},
    legend pos=north west,
    grid=major,
    width=0.8\textwidth,
    height=6cm,
    xtick={1,3,5,10,20}
]
\addplot[color=red,mark=square*,thick] coordinates {
    (1,84104)
    (3,241388)
    (5,398068)
    (10,685895)
    (20,1374283)
};
\legend{P=K=20}
\end{axis}
\end{tikzpicture}
\caption{Wpływ liczby buforów na przepustowość (P=K=20)}
\label{fig:buffers_impact}
\end{figure}

\textbf{Wnioski:}
\begin{itemize}
    \item Liczba buforów ma krytyczny wpływ na wydajność
    \item Przy 1 buforze: wąskie gardło (84k elem/s)
    \item Przy 20 buforach: 1.37M elem/s (wzrost 16×)
\end{itemize}

\subsection{Równomierność rozkładu obciążenia}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    ybar,
    xlabel={Bufor},
    ylabel={Liczba elementów},
    symbolic x coords={Bufor 0, Bufor 1, Bufor 2},
    xtick=data,
    width=0.8\textwidth,
    height=6cm,
    nodes near coords,
    nodes near coords align={vertical},
]
\addplot coordinates {(Bufor 0,423241) (Bufor 1,421983) (Bufor 2,422712)};
\end{axis}
\end{tikzpicture}
\caption{Rozkład obciążenia buforów dla testu P=5, B=3, K=5}
\label{fig:load_distribution}
\end{figure}

\textbf{Analiza równomierności:}
\begin{itemize}
    \item Średnia na bufor: 422 645
    \item Odchylenie standardowe: 516
    \item Współczynnik zmienności: 0.12\%
    \item Ocena: \textbf{DOSKONAŁE} równoważenie
\end{itemize}

\subsection{Współczynnik zmienności}

\begin{table}[H]
\centering
\caption{Współczynnik zmienności dla wybranych konfiguracji}
\begin{tabular}{@{}cccc@{}}
\toprule
\textbf{P} & \textbf{B} & \textbf{K} & \textbf{CV [\%]} \\ \midrule
5 & 3 & 5 & 0.12 \\
10 & 3 & 10 & 0.15 \\
20 & 3 & 20 & 0.12 \\
50 & 3 & 50 & 0.03 \\
100 & 3 & 100 & 0.04 \\
20 & 10 & 20 & 0.08 \\
\bottomrule
\end{tabular}
\end{table}

Wszystkie konfiguracje wykazują współczynnik zmienności $< 1\%$, co potwierdza skuteczność algorytmu równoważenia.

\section{Analiza wydajności}

\subsection{Efektywność produkcji i konsumpcji}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    xlabel={Numer testu},
    ylabel={Liczba elementów},
    legend pos=north west,
    grid=major,
    width=0.8\textwidth,
    height=6cm,
    xtick={1,2,3,4,5}
]
\addplot[color=blue,mark=*] coordinates {
    (1,1269816) (2,2011533) (3,2377944) (4,3227240) (5,4391217)
};
\addplot[color=red,mark=square] coordinates {
    (1,1267936) (2,2010223) (3,2376691) (4,3225625) (5,4390764)
};
\legend{Wyprodukowano, Skonsumowano}
\end{axis}
\end{tikzpicture}
\caption{Produkcja vs konsumpcja (Serie 1)}
\label{fig:production_consumption}
\end{figure}

\textbf{Strata danych:}
\begin{equation}
\text{Strata} = \frac{\text{Wyprodukowano} - \text{Skonsumowano}}{\text{Wyprodukowano}} \times 100\%
\end{equation}

Średnia strata: $< 0.1\%$ -- bardzo wysoka efektywność.

\subsection{Czas rzeczywisty vs nominalny}

\begin{table}[H]
\centering
\caption{Dokładność czasu wykonania}
\begin{tabular}{@{}cccc@{}}
\toprule
\textbf{Test} & \textbf{Nominalny [s]} & \textbf{Rzeczywisty [ms]} & \textbf{Odchylenie} \\ \midrule
1 & 10 & 10012 & +0.12\% \\
2 & 10 & 10137 & +1.37\% \\
3 & 10 & 10001 & +0.01\% \\
4 & 10 & 10002 & +0.02\% \\
5 & 10 & 10053 & +0.53\% \\
\bottomrule
\end{tabular}
\end{table}

System wykazuje wysoką precyzję czasową.

\section{Szczegóły Implementacji}

\subsection{Kluczowe fragmenty kodu}

\subsubsection{Wybór bufora na podstawie wag}

\begin{lstlisting}[caption={Metoda selectByWeight}]
private static int selectByWeight(double[] weights, Random rand) {
    double total = 0;
    for (double w : weights) total += w;
    
    double r = rand.nextDouble() * total;
    double cumulative = 0;
    
    for (int i = 0; i < weights.length; i++) {
        cumulative += weights[i];
        if (r <= cumulative) return i;
    }
    return weights.length - 1;
}
\end{lstlisting}

\subsubsection{Aktualizacja wag}

\begin{lstlisting}[caption={Metoda updateWeight}]
private static void updateWeight(double[] weights, int index, 
                                  long waitTimeNanos) {
    double newWeight = 1.0 / (1.0 + waitTimeNanos / 1_000_000.0);
    weights[index] = 0.7 * weights[index] + 0.3 * newWeight;
    if (weights[index] < 0.01) weights[index] = 0.01;
}
\end{lstlisting}

\section{Wnioski}

\subsection{Zalety systemu}

\begin{enumerate}
    \item \textbf{Doskonałe równoważenie obciążenia} -- współczynnik zmienności $< 0.2\%$
    \item \textbf{Wysoka skalowalność} -- liniowy wzrost przepustowości
    \item \textbf{Niska strata danych} -- $< 0.1\%$
    \item \textbf{Elastyczność} -- działa w różnych konfiguracjach
\end{enumerate}

\subsection{Ograniczenia}

\begin{enumerate}
    \item Overhead komunikacji z dispatcherami
    \item Wpływ liczby buforów na złożoność
    \item Wymaga dostrajania parametrów $\alpha$
\end{enumerate}

\subsection{Możliwe usprawnienia}

\begin{itemize}
    \item Adaptacyjne dostosowanie współczynnika wygładzania
    \item Hierarchiczne dispatchery dla bardzo dużych systemów
    \item Predykcja obciążenia przy użyciu ML
    \item Dynamiczne dodawanie/usuwanie buforów
\end{itemize}

\section{Podsumowanie}

System producent-konsument z tablicami wag i dispatcherami wykazuje doskonałe właściwości równoważenia obciążenia przy wysokiej wydajności. Implementacja oparta na JCSP i \texttt{ArrayBlockingQueue} zapewnia niezawodność i skalowalność. Wyniki eksperymentów potwierdzają efektywność algorytmu w szerokim zakresie konfiguracji.

\end{document}